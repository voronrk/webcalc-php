На предыдущие задания сдавались другие проекты, поэтому здесь начнётся с 4-го.
Проект пишется сравнительно давно и потихоньку рефакторится, но этот процесс пока не завершён, поэтому не всё соответствует стандартам и не всё откомментировано.

Задание 4.
----------
01. Перенести всю логику из предыдущих заданий в классы.
02. Написать сущности (например Статья - это сущность) по которой можно работать как с объектом.
03. Добавить минимум 1 абстрактный класс и 1 интерфейс.
04. Обращение к БД вынести в отдельный класс для работы с БД.

Интерфейсы лежат в папке Interfaces, классы для работы с данными - в папке Models. Там есть класс Database для работы с базой данных, но поскольку база данных ещё не спроектирована, класс не задействован, а данные лежат в константах в соответствующих классах.
Для большинства групп сущностей созданы абстрактные классы, описывающие общую логику и структуру.

Задание 5.
----------
01. Проанализировать проект, созданный на прошлых занятиях.
02. Там, где необходимо, привести код в соответствие принципам программирования.
03. При написании кода стараться придерживаться этих принципов.

SRP
Каждый класс описывает отдельную часть бизнес-задачи и может быть изменён только если изменится способ работы именно с этой частью (например, изменится алгоритм расчёта количества краски).
OPC
Пример этого принципа - классы для работы с материалами. Все они являются наследниками абстрактного класса Material, расширяя его функциональность.
LSP
В данном проекте нет примеров его использования.
ISP
В интерфейсе DataInterface в процессе рефакторинга были убраны методы GetById и GetAllById, являющиеся частными случаями методов GetByKey и GetAllByKey соответственно. Методы реализованы в абстрактном классе GetData.
DIP
С этим принципом сложнее. В классах группы MainClasses некоторые свойства определяются через классы непосредственно в конструкторе. Наверное, можно вынести их наружу и передавать в параметрах класса в виде объекта, но, скажем, объект класса Layout не имеет смысла вне объекта класса Halfproduct. С одной стороны, такой подход делает алгоритм менее универсальным (мы привязаны к конкретному способу расчёта макета), с другой - попытка сделать алгоритм более универсальным нарушит принцип KISS.
DRY
Везде, где можно, повторяющийся код вынесен в отдельные классы или функции.
KISS
Данный проект разрабатывается под одну узкую задачу, поэтому некоторые функции реализованы негибко и местами даже костылями, поскольку попытки сделать их более универсальными сильно усложнят алгоритм, что на данном этапе излишне.


Вопросы к ментору
-----------------
1. В классе Worker свойство jobTariff заполняется в конструкторе через обращение к статическому классу GetJobTariffs. Корректно ли так делать? Если нет, то как правильно? 
2. В конструкторах классов MainClasses\Suboperation и MainClasses\Halfproduct создаются объекты нескольких классов (Worker, Layout, Ink, Paper, etc). Наверное, это нарушает принцип DIP, но я не очень представляю, как вынести создание этих объектов наружу класса (учитывая, что часть параметров для них является свойствами этого класса). Буду благодарен за совет.